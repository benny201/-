# TCP 运输控制协议

## 主要特点：
* 面向连接的运输层协议。
```
使用前建立连接，使用后必须释放连接。
```
* 每一条TCP连接只能有两个端点，即点对点连接。
* 提供可靠交付服务。
```
无差错，不丢失，不重复
```
* 双全工通信
```
允许通信双方任何时候都可以发送数据。连接的两端都设有发送缓存和接受缓存。
```
* 面向字节流。
```
流是指流入到进程或者从进程流出的字节序列。
它把上面应用层交下来的数据看成无结构的字节流来发送，可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小。
```

### TCP的连接
TCP的连接有两个端点，TCP连接的端点叫socket（套接字）：端口号拼接到IP地址即构成了套接字。
所以套接字就是：在点分十进制的IP地址后面写上端口号中间用冒号或者逗号隔开（192.3.4.5:80）。

## 可靠传输的工作原理（非TCP实现）
TCP的报文都是交给IP层传送的。但IP层职能提供尽最大努力服务，也就是说，TCP下面的网络所提供的是不可靠传输。

### 如何将不可靠的传输变成可靠
* 当出现差错是，让发送方重传出现差错的数据
* 当接收方来不及处理受到的数据时，及时让发送方降低速度。

### 停止等待协议
出现差错时：
发送方在一定时间内没收到ACK，则重新传前面的分组：`超时重传`
信道利用率：
停止等待协议缺点是信道利用率太低。
信道利用率：U ＝ （发送packet用的时间Td ／ （Td ＋ 发送确认信息Ta ＋ 往返时间即发送和确认发送的中间时间））

### 连续ARQ协议
连续发送多个分组，不是等待确认逐个发。
ARQ规定，每收到一个确认就把发送窗口向前滑动一个分组的位置。

## TCP报文段的首部格式
TCP虽然是面向字节流的，但是TCP传送的数据单元却是报文段。首部的前20个字节是固定的（5层4字节）。
* 源端口和目的端口：各2字节
* 序号：4字节，`mod 2的32次方运算`，序号段的值指的是本报文段所发送的数据的第一个字节的序号，接下来的字节依次加一。
* 确认号ack
```
是期望收到对方`下一个`报文段的第一个数据字节的序号。
确认号为N即说明N－1为止的所有数据都已正确收到。
```
* 数据偏移：占4位，实际上是指出TCP报文段的首部长度。数据偏移的单位是4字节，所以最大便宜是60字节。
* 保留：留作后用
* 6个控制位：
```
1. 紧急URG：若为1则说明报文段有紧急数据，尽快传送，不按照原来的排队顺序传送（不是放到TCP缓存尾部）。
而且会把紧急数据放到本报文段的最前面。

2. 确认ACK：若为1则确认号字段有效。建立TCP连接后，所有传送的报文段ACK都为1.

3. 推送PSH：PSH为1则立刻创建一个报文段发送，而不用等到整个缓存填满了再交付。

4. 复位RST：RST为1则释放连接

5. 同步SYN：SYN为1则说明这是一个连接请求或者连接接受报文（3次握手时，先发syn＝1，ack＝0， 再返回一个syn＝1，ack＝1）

6. 窗口FIN：两字节，窗口字段指明对方发送的数据量。
```
* 检验和 以及 紧急指针：
```
检验和：两字节，检验首部和数据

紧急指针：两字节，当URG ＝ 1时才有意义，指出本报本段的紧急数据的字节，紧急指针指出了`紧急数据的末尾`在报文段中的位置。
窗口为0时也可以发送紧急数据。
```

## TCP可靠传输的实现
根据确认号确定发送的开始序号，再由窗口确定窗口的长度。
发送窗口表示，在没有接受方B的确认情况下，发送方A可以连续把窗口内的数据都发送出去。
凡是发送过的数据，在未收到确认之前要暂存，以防超时重传。
发送窗口会根据收到确认后，不断前移。


## TCP的流量控制
`流量控制就是让发送方的发送速率不要太快，要让接受方来得及接收`。
利用滑动窗口机制可以实现流量控制。

过程：
```
A向B发送数据，建立连接时，B会告诉A接收窗口大小，所以发送方的发送窗口不能超过接收方给出的接收窗口数值。
窗口的单位时字节。
实现一次流量控制就是：给发送方设定新的窗口大小。如果窗口大小为0，则为不允许发送方发送新数据。
为了防止死锁持续下去，发送方会设定一个零窗口持续计时器，到一定时间会给接受方发送一个字节为1的探测报文段，寻求新的窗口值。
```

### 传输速率的控制
即控制TCP报文段的发送时机：
* 维持一个最大报文段长度MSS，达到MSS字节就发送。
* 由发送方指明要发送报文段，即PSH操作。
* 设定一个发送计时器，到达一定时间就发送。
* Nagle算法：
```
应用进程把要发送的数据逐个字节送到TCP缓存，则发送方就把第一个数据字节先发送出去，
然后收到确认后，把缓存里的数据再发送出去，以此内推。
Nagle算法还规定，数据已经达到窗口大小的一半时或者达到MSS则也要发送。
```

## TCP的拥堵控制
待续。

## TCP的运输连接管理
* TCP是面相连接的协议。
* TCP连接的建立采用客户服务器方式。
* 主动发起连接建立的应用进程叫做`客户`，被动等待连接建立的应用进程叫做`服务器`。
运输连接由三个阶段：连接建立，数据传送，连接释放。



### TCP的连接建立
1. 服务器进程先创建`传输控制块`，准备接受客户进程的连接请求。
2. 客户端也先创建传输控制块TCB，然后向服务器进程发送连接请求报文段，这时候同步位SYN ＝ 1，同时选择一个初始序号seq＝x
   客户进程进入`SYN－SENT`状态。
3. 服务进程收到报文后，向A发送请求，然后SYN和ACK都置1，ack ＝ x＋ 1（确认号），同时也初始化自己的序号seq ＝ y，不携带数据，消耗一个序号
   服务器进程进入`SYN－RCVD`状态
4. 客服端进程收到确认后，向B给出确认，ACK置1，ack ＝ y ＋ 1，自己的序号seq ＝ x ＋ 1.
  （TCP规定ACK报文段可以携带数据，但是如果不携带数据，不消耗序号，所以下一个数据报文段还是x ＋ 1）。
   此时客户端进程进入established状态。
5. 服务器端进程收到确认后也进入established状态。
6. 以上过程叫做：TCP的三次握手


### 为什么需要第三次握手
因为有可能客户先给服务器发送一个连接请求，但是因为在某些网络节点滞留了，导致了客户和服务器后面的连接释放了，才到达服务器，
这时候服务器以为客服端又发出了一个新的请求，如果不是三次握手的话，这时候连接就确立了，然后服务器给客户发送一个确认报文，
但是客户并不会理会这个确认报文，这时候服务器一直等待客户发送数据，但是并不会发生，造成了资源的浪费。


### TCP的连接释放
1. 客户端进程先向服务器端发送一个FIN＝1，seq＝u的连接释放报文段。
   客户端进入`FIN－wait－1`状态，FIN报文段必须消耗序号
2. 服务端进程收到释放报文后发出确认，ack ＝ u ＋ 1，seq ＝ v（等于服务器前面已传送过的数据最后一个字节的序号加1）
   服务端进入`CLOSE－wait`状态
3. TCP会在此时通知高层应用进程，因而客户到服务器这个方向连接已经释放了。TCP处于半关闭状态。
   但是此时B还有可能发送数据，A仍然会接收，但是不会发送，
4. 之后在客户收到服务器的确认报文后，进入`FIN－wait－2`状态，等待服务器发送连接释放报文。
5. 再之后，服务器若已经没有数据要发送给客户，则会发送一个连接释放报文，使得FIN＝1，ack ＝ u ＋ 1.
   服务器进入`LAST－ACK`状态
6. 客户收到服务器的连接释放报文段后，发送一个确认报文段，ACK置1， ack ＝ w ＋ 1（假设期间服务器还给客户发送了w个序号的数据，且前面的FIN消耗了一个序号）
   客户进入`TIME－WAIT`状态
7. 此时TCP还没有释放，必须经过时间等待计时器（TIME——WAIT）设置的时间2MSL后，A才进入`CLOSED`状态。
8. MSL：Maximun Segment Lifetime 最长报文段寿命  一般为2分钟


### 为什么客户在TIME－WAIT状态必须等待2MSL的时间呢？
* 确保客户发送的最后一个ACK报文能够到达服务器端。因为这个ACK报文有可能丢失。服务端会超时重传。
* 防止已失效的连接请求报文段存在网络中。与三次握手的忧虑一样。

